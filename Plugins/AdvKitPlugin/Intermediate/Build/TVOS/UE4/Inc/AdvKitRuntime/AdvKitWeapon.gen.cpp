// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "UObject/GeneratedCppIncludes.h"
#include "AdvKitRuntime/Public/Items/AdvKitWeapon.h"
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable : 4883)
#endif
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeAdvKitWeapon() {}
// Cross Module References
	ADVKITRUNTIME_API UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState();
	UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	ADVKITRUNTIME_API UScriptStruct* Z_Construct_UScriptStruct_FAdvKitWeaponState();
	ADVKITRUNTIME_API UClass* Z_Construct_UClass_AAdvKitWeapon_NoRegister();
	ADVKITRUNTIME_API UClass* Z_Construct_UClass_AAdvKitWeapon();
	ADVKITRUNTIME_API UClass* Z_Construct_UClass_AAdvKitInventoryItem();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddSpread();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockDamage();
	ENGINE_API UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API UClass* Z_Construct_UClass_AController_NoRegister();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FDamageEvent();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockedBy();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanFire();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanReload();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireCustom();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireInstant();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireProjectile();
	ADVKITRUNTIME_API UClass* Z_Construct_UClass_AAdvKitProjectile_NoRegister();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP();
	ADVKITRUNTIME_API UClass* Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass();
	COREUOBJECT_API UClass* Z_Construct_UClass_UClass();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture();
	ENGINE_API UClass* Z_Construct_UClass_UTexture2D_NoRegister();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasFireMode();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsFiring();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsIdle();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsReloading();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireShot();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloaded();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_RefireTimer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFire();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireServer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReload();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFire();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireServer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReload();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer();
	ADVKITRUNTIME_API UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer();
	ENGINE_API UClass* Z_Construct_UClass_UAnimMontage_NoRegister();
	ENGINE_API UClass* Z_Construct_UClass_USceneComponent_NoRegister();
// End Cross Module References
	static UEnum* EAdvKitWeaponState_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("EAdvKitWeaponState"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAdvKitWeaponState(EAdvKitWeaponState_StaticEnum, TEXT("/Script/AdvKitRuntime"), TEXT("EAdvKitWeaponState"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState_CRC() { return 3912651424U; }
	UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAdvKitWeaponState"), 0, Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EAdvKitWeaponState::Idle", (int64)EAdvKitWeaponState::Idle },
				{ "EAdvKitWeaponState::Firing", (int64)EAdvKitWeaponState::Firing },
				{ "EAdvKitWeaponState::Reloading", (int64)EAdvKitWeaponState::Reloading },
			};
#if WITH_METADATA
			const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
				{ "ToolTip", "@brief States a weapon can be in" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_AdvKitRuntime,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EAdvKitWeaponState",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"EAdvKitWeaponState",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
class UScriptStruct* FAdvKitWeaponState::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAdvKitWeaponState, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("AdvKitWeaponState"), sizeof(FAdvKitWeaponState), Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAdvKitWeaponState(FAdvKitWeaponState::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("AdvKitWeaponState"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitWeaponState
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitWeaponState()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AdvKitWeaponState")),new UScriptStruct::TCppStructOps<FAdvKitWeaponState>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitWeaponState;
	struct Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[];
#endif
		static void* NewStructOps();
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bWantsToReload_MetaData[];
#endif
		static void NewProp_bWantsToReload_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bWantsToReload;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bWantsToFire_MetaData[];
#endif
		static void NewProp_bWantsToFire_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bWantsToFire;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_PendingFireMode_MetaData[];
#endif
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_PendingFireMode;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ActiveFireMode_MetaData[];
#endif
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_ActiveFireMode;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_State_MetaData[];
#endif
		static const UE4CodeGen_Private::FEnumPropertyParams NewProp_State;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_State_Underlying;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
		static const UE4CodeGen_Private::FStructParams ReturnStructParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::Struct_MetaDataParams[] = {
		{ "BlueprintType", "true" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "@brief Helper struct to handle replication of all relevant weapon properties" },
	};
#endif
	void* Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewStructOps()
	{
		return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FAdvKitWeaponState>();
	}
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToReload_MetaData[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Flag to set that weapon wants to reload as soon as possible" },
	};
#endif
	void Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToReload_SetBit(void* Obj)
	{
		((FAdvKitWeaponState*)Obj)->bWantsToReload = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToReload = { UE4CodeGen_Private::EPropertyClass::Bool, "bWantsToReload", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000014, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FAdvKitWeaponState), &Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToReload_SetBit, METADATA_PARAMS(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToReload_MetaData, ARRAY_COUNT(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToReload_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToFire_MetaData[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Flag to set that the weapon wants to fire (even if it can't)" },
	};
#endif
	void Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToFire_SetBit(void* Obj)
	{
		((FAdvKitWeaponState*)Obj)->bWantsToFire = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToFire = { UE4CodeGen_Private::EPropertyClass::Bool, "bWantsToFire", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000014, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FAdvKitWeaponState), &Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToFire_SetBit, METADATA_PARAMS(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToFire_MetaData, ARRAY_COUNT(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToFire_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_PendingFireMode_MetaData[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Set in case the weapon wants to change fire modes" },
	};
#endif
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_PendingFireMode = { UE4CodeGen_Private::EPropertyClass::Byte, "PendingFireMode", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000014, 1, nullptr, STRUCT_OFFSET(FAdvKitWeaponState, PendingFireMode), nullptr, METADATA_PARAMS(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_PendingFireMode_MetaData, ARRAY_COUNT(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_PendingFireMode_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_ActiveFireMode_MetaData[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Which fire mode is currently active" },
	};
#endif
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_ActiveFireMode = { UE4CodeGen_Private::EPropertyClass::Byte, "ActiveFireMode", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000014, 1, nullptr, STRUCT_OFFSET(FAdvKitWeaponState, ActiveFireMode), nullptr, METADATA_PARAMS(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_ActiveFireMode_MetaData, ARRAY_COUNT(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_ActiveFireMode_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_State_MetaData[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "The current weapon state" },
	};
#endif
	const UE4CodeGen_Private::FEnumPropertyParams Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_State = { UE4CodeGen_Private::EPropertyClass::Enum, "State", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000014, 1, nullptr, STRUCT_OFFSET(FAdvKitWeaponState, State), Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState, METADATA_PARAMS(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_State_MetaData, ARRAY_COUNT(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_State_MetaData)) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_State_Underlying = { UE4CodeGen_Private::EPropertyClass::Byte, "UnderlyingType", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0000000000000000, 1, nullptr, 0, nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToReload,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_bWantsToFire,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_PendingFireMode,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_ActiveFireMode,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_State,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::NewProp_State_Underlying,
	};
	const UE4CodeGen_Private::FStructParams Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::ReturnStructParams = {
		(UObject* (*)())Z_Construct_UPackage__Script_AdvKitRuntime,
		nullptr,
		&NewStructOps,
		"AdvKitWeaponState",
		RF_Public|RF_Transient|RF_MarkAsNative,
		EStructFlags(0x00000001),
		sizeof(FAdvKitWeaponState),
		alignof(FAdvKitWeaponState),
		Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::PropPointers),
		METADATA_PARAMS(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::Struct_MetaDataParams, ARRAY_COUNT(Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::Struct_MetaDataParams))
	};
	UScriptStruct* Z_Construct_UScriptStruct_FAdvKitWeaponState()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AdvKitWeaponState"), sizeof(FAdvKitWeaponState), Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, Z_Construct_UScriptStruct_FAdvKitWeaponState_Statics::ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC() { return 3998914119U; }
	static FName NAME_AAdvKitWeapon_AddAmmunition = FName(TEXT("AddAmmunition"));
	void AAdvKitWeapon::AddAmmunition(int32 Amount)
	{
		AdvKitWeapon_eventAddAmmunition_Parms Parms;
		Parms.Amount=Amount;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_AddAmmunition),&Parms);
	}
	static FName NAME_AAdvKitWeapon_BlockDamage = FName(TEXT("BlockDamage"));
	float AAdvKitWeapon::BlockDamage(float Damage, FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)
	{
		AdvKitWeapon_eventBlockDamage_Parms Parms;
		Parms.Damage=Damage;
		Parms.DamageEvent=DamageEvent;
		Parms.EventInstigator=EventInstigator;
		Parms.DamageCauser=DamageCauser;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_BlockDamage),&Parms);
		return Parms.ReturnValue;
	}
	static FName NAME_AAdvKitWeapon_BlockedBy = FName(TEXT("BlockedBy"));
	void AAdvKitWeapon::BlockedBy(AActor* By, float BlockedDamage)
	{
		AdvKitWeapon_eventBlockedBy_Parms Parms;
		Parms.By=By;
		Parms.BlockedDamage=BlockedDamage;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_BlockedBy),&Parms);
	}
	static FName NAME_AAdvKitWeapon_CanFire = FName(TEXT("CanFire"));
	bool AAdvKitWeapon::CanFire()
	{
		AdvKitWeapon_eventCanFire_Parms Parms;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_CanFire),&Parms);
		return !!Parms.ReturnValue;
	}
	static FName NAME_AAdvKitWeapon_CanReload = FName(TEXT("CanReload"));
	bool AAdvKitWeapon::CanReload()
	{
		AdvKitWeapon_eventCanReload_Parms Parms;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_CanReload),&Parms);
		return !!Parms.ReturnValue;
	}
	static FName NAME_AAdvKitWeapon_ConsumeAmmunition = FName(TEXT("ConsumeAmmunition"));
	void AAdvKitWeapon::ConsumeAmmunition()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_ConsumeAmmunition),NULL);
	}
	static FName NAME_AAdvKitWeapon_FireAmmunition = FName(TEXT("FireAmmunition"));
	void AAdvKitWeapon::FireAmmunition()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_FireAmmunition),NULL);
	}
	static FName NAME_AAdvKitWeapon_FireCustom = FName(TEXT("FireCustom"));
	void AAdvKitWeapon::FireCustom()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_FireCustom),NULL);
	}
	static FName NAME_AAdvKitWeapon_FireInstant = FName(TEXT("FireInstant"));
	void AAdvKitWeapon::FireInstant()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_FireInstant),NULL);
	}
	static FName NAME_AAdvKitWeapon_FireProjectile = FName(TEXT("FireProjectile"));
	AAdvKitProjectile* AAdvKitWeapon::FireProjectile()
	{
		AdvKitWeapon_eventFireProjectile_Parms Parms;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_FireProjectile),&Parms);
		return Parms.ReturnValue;
	}
	static FName NAME_AAdvKitWeapon_GetMuzzleLocation = FName(TEXT("GetMuzzleLocation"));
	FVector AAdvKitWeapon::GetMuzzleLocation(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventGetMuzzleLocation_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_GetMuzzleLocation),&Parms);
		return Parms.ReturnValue;
	}
	static FName NAME_AAdvKitWeapon_GetTraceStart = FName(TEXT("GetTraceStart"));
	FVector AAdvKitWeapon::GetTraceStart(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventGetTraceStart_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_GetTraceStart),&Parms);
		return Parms.ReturnValue;
	}
	static FName NAME_AAdvKitWeapon_HandleFiringPrerequisites = FName(TEXT("HandleFiringPrerequisites"));
	void AAdvKitWeapon::HandleFiringPrerequisites()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_HandleFiringPrerequisites),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnFireBegin = FName(TEXT("OnFireBegin"));
	void AAdvKitWeapon::OnFireBegin()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnFireBegin),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnFireEnd = FName(TEXT("OnFireEnd"));
	void AAdvKitWeapon::OnFireEnd()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnFireEnd),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnFireShot = FName(TEXT("OnFireShot"));
	void AAdvKitWeapon::OnFireShot()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnFireShot),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnMagazineEmpty = FName(TEXT("OnMagazineEmpty"));
	void AAdvKitWeapon::OnMagazineEmpty()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnMagazineEmpty),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnReloadBegin = FName(TEXT("OnReloadBegin"));
	void AAdvKitWeapon::OnReloadBegin()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnReloadBegin),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnReloaded = FName(TEXT("OnReloaded"));
	void AAdvKitWeapon::OnReloaded()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnReloaded),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnReloadEnd = FName(TEXT("OnReloadEnd"));
	void AAdvKitWeapon::OnReloadEnd()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnReloadEnd),NULL);
	}
	static FName NAME_AAdvKitWeapon_OnWeaponEmpty = FName(TEXT("OnWeaponEmpty"));
	void AAdvKitWeapon::OnWeaponEmpty()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_OnWeaponEmpty),NULL);
	}
	static FName NAME_AAdvKitWeapon_ReloadAmmunition = FName(TEXT("ReloadAmmunition"));
	void AAdvKitWeapon::ReloadAmmunition()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_ReloadAmmunition),NULL);
	}
	static FName NAME_AAdvKitWeapon_StartFire = FName(TEXT("StartFire"));
	void AAdvKitWeapon::StartFire(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventStartFire_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StartFire),&Parms);
	}
	static FName NAME_AAdvKitWeapon_StartFireInternal = FName(TEXT("StartFireInternal"));
	void AAdvKitWeapon::StartFireInternal()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StartFireInternal),NULL);
	}
	static FName NAME_AAdvKitWeapon_StartFireServer = FName(TEXT("StartFireServer"));
	void AAdvKitWeapon::StartFireServer(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventStartFireServer_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StartFireServer),&Parms);
	}
	static FName NAME_AAdvKitWeapon_StartReload = FName(TEXT("StartReload"));
	void AAdvKitWeapon::StartReload()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StartReload),NULL);
	}
	static FName NAME_AAdvKitWeapon_StartReloadInternal = FName(TEXT("StartReloadInternal"));
	void AAdvKitWeapon::StartReloadInternal()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StartReloadInternal),NULL);
	}
	static FName NAME_AAdvKitWeapon_StartReloadServer = FName(TEXT("StartReloadServer"));
	void AAdvKitWeapon::StartReloadServer()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StartReloadServer),NULL);
	}
	static FName NAME_AAdvKitWeapon_StartReloadTimer = FName(TEXT("StartReloadTimer"));
	void AAdvKitWeapon::StartReloadTimer()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StartReloadTimer),NULL);
	}
	static FName NAME_AAdvKitWeapon_StopFire = FName(TEXT("StopFire"));
	void AAdvKitWeapon::StopFire()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StopFire),NULL);
	}
	static FName NAME_AAdvKitWeapon_StopFireInternal = FName(TEXT("StopFireInternal"));
	void AAdvKitWeapon::StopFireInternal()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StopFireInternal),NULL);
	}
	static FName NAME_AAdvKitWeapon_StopFireServer = FName(TEXT("StopFireServer"));
	void AAdvKitWeapon::StopFireServer()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StopFireServer),NULL);
	}
	static FName NAME_AAdvKitWeapon_StopReload = FName(TEXT("StopReload"));
	void AAdvKitWeapon::StopReload()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StopReload),NULL);
	}
	static FName NAME_AAdvKitWeapon_StopReloadInternal = FName(TEXT("StopReloadInternal"));
	void AAdvKitWeapon::StopReloadInternal()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StopReloadInternal),NULL);
	}
	static FName NAME_AAdvKitWeapon_StopReloadServer = FName(TEXT("StopReloadServer"));
	void AAdvKitWeapon::StopReloadServer()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StopReloadServer),NULL);
	}
	static FName NAME_AAdvKitWeapon_StopReloadTimer = FName(TEXT("StopReloadTimer"));
	void AAdvKitWeapon::StopReloadTimer()
	{
		ProcessEvent(FindFunctionChecked(NAME_AAdvKitWeapon_StopReloadTimer),NULL);
	}
	void AAdvKitWeapon::StaticRegisterNativesAAdvKitWeapon()
	{
		UClass* Class = AAdvKitWeapon::StaticClass();
		static const FNameNativePtrPair Funcs[] = {
			{ "AddAmmunition", &AAdvKitWeapon::execAddAmmunition },
			{ "AddSpread", &AAdvKitWeapon::execAddSpread },
			{ "BlockDamage", &AAdvKitWeapon::execBlockDamage },
			{ "BlockedBy", &AAdvKitWeapon::execBlockedBy },
			{ "CanFire", &AAdvKitWeapon::execCanFire },
			{ "CanReload", &AAdvKitWeapon::execCanReload },
			{ "ConsumeAmmunition", &AAdvKitWeapon::execConsumeAmmunition },
			{ "FireAmmunition", &AAdvKitWeapon::execFireAmmunition },
			{ "FireCustom", &AAdvKitWeapon::execFireCustom },
			{ "FireInstant", &AAdvKitWeapon::execFireInstant },
			{ "FireProjectile", &AAdvKitWeapon::execFireProjectile },
			{ "GetAdjustedAim", &AAdvKitWeapon::execGetAdjustedAim },
			{ "GetFireModeBP", &AAdvKitWeapon::execGetFireModeBP },
			{ "GetFireModeClass", &AAdvKitWeapon::execGetFireModeClass },
			{ "GetMuzzleLocation", &AAdvKitWeapon::execGetMuzzleLocation },
			{ "GetTraceStart", &AAdvKitWeapon::execGetTraceStart },
			{ "GetWeaponCrosshairTexture", &AAdvKitWeapon::execGetWeaponCrosshairTexture },
			{ "HandleFiringPrerequisites", &AAdvKitWeapon::execHandleFiringPrerequisites },
			{ "HasAmmunition", &AAdvKitWeapon::execHasAmmunition },
			{ "HasAmmunitionInMagazine", &AAdvKitWeapon::execHasAmmunitionInMagazine },
			{ "HasFireMode", &AAdvKitWeapon::execHasFireMode },
			{ "IsFiring", &AAdvKitWeapon::execIsFiring },
			{ "IsIdle", &AAdvKitWeapon::execIsIdle },
			{ "IsMagazineEmpty", &AAdvKitWeapon::execIsMagazineEmpty },
			{ "IsReloading", &AAdvKitWeapon::execIsReloading },
			{ "OnFireBegin", &AAdvKitWeapon::execOnFireBegin },
			{ "OnFireEnd", &AAdvKitWeapon::execOnFireEnd },
			{ "OnFireShot", &AAdvKitWeapon::execOnFireShot },
			{ "OnMagazineEmpty", &AAdvKitWeapon::execOnMagazineEmpty },
			{ "OnReloadBegin", &AAdvKitWeapon::execOnReloadBegin },
			{ "OnReloaded", &AAdvKitWeapon::execOnReloaded },
			{ "OnReloadEnd", &AAdvKitWeapon::execOnReloadEnd },
			{ "OnRep_BurstCounter", &AAdvKitWeapon::execOnRep_BurstCounter },
			{ "OnRep_WeaponState", &AAdvKitWeapon::execOnRep_WeaponState },
			{ "OnWeaponEmpty", &AAdvKitWeapon::execOnWeaponEmpty },
			{ "RefireTimer", &AAdvKitWeapon::execRefireTimer },
			{ "ReloadAmmunition", &AAdvKitWeapon::execReloadAmmunition },
			{ "ReloadedTimer", &AAdvKitWeapon::execReloadedTimer },
			{ "StartFire", &AAdvKitWeapon::execStartFire },
			{ "StartFireInternal", &AAdvKitWeapon::execStartFireInternal },
			{ "StartFireServer", &AAdvKitWeapon::execStartFireServer },
			{ "StartRefireTimer", &AAdvKitWeapon::execStartRefireTimer },
			{ "StartReload", &AAdvKitWeapon::execStartReload },
			{ "StartReloadInternal", &AAdvKitWeapon::execStartReloadInternal },
			{ "StartReloadServer", &AAdvKitWeapon::execStartReloadServer },
			{ "StartReloadTimer", &AAdvKitWeapon::execStartReloadTimer },
			{ "StopFire", &AAdvKitWeapon::execStopFire },
			{ "StopFireInternal", &AAdvKitWeapon::execStopFireInternal },
			{ "StopFireServer", &AAdvKitWeapon::execStopFireServer },
			{ "StopRefireTimer", &AAdvKitWeapon::execStopRefireTimer },
			{ "StopReload", &AAdvKitWeapon::execStopReload },
			{ "StopReloadInternal", &AAdvKitWeapon::execStopReloadInternal },
			{ "StopReloadServer", &AAdvKitWeapon::execStopReloadServer },
			{ "StopReloadTimer", &AAdvKitWeapon::execStopReloadTimer },
		};
		FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, ARRAY_COUNT(Funcs));
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics
	{
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_Amount;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::NewProp_Amount = { UE4CodeGen_Private::EPropertyClass::Int, "Amount", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventAddAmmunition_Parms, Amount), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::NewProp_Amount,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Adds ammunition to the weapon\n@param       Amount  How much to add." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "AddAmmunition", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, sizeof(AdvKitWeapon_eventAddAmmunition_Parms), Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics
	{
		struct AdvKitWeapon_eventAddSpread_Parms
		{
			FRotator OriginalAim;
			uint8 FireModeIndex;
			FRotator ReturnValue;
		};
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_OriginalAim;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Struct, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventAddSpread_Parms, ReturnValue), Z_Construct_UScriptStruct_FRotator, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventAddSpread_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::NewProp_OriginalAim = { UE4CodeGen_Private::EPropertyClass::Struct, "OriginalAim", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventAddSpread_Parms, OriginalAim), Z_Construct_UScriptStruct_FRotator, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::NewProp_FireModeIndex,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::NewProp_OriginalAim,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "CPP_Default_FireModeIndex", "0" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Add spread to a fire orientation.\n@param       OriginalAim     Original fire orientation.\n@param       FireModeIndex   Different fire modes can have different spreads.\n@return Modified aim rotation." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "AddSpread", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04820400, sizeof(AdvKitWeapon_eventAddSpread_Parms), Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddSpread()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_AddSpread_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics
	{
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_DamageCauser;
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_EventInstigator;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DamageEvent_MetaData[];
#endif
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_DamageEvent;
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Damage;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FFloatPropertyParams Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Float, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventBlockDamage_Parms, ReturnValue), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_DamageCauser = { UE4CodeGen_Private::EPropertyClass::Object, "DamageCauser", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventBlockDamage_Parms, DamageCauser), Z_Construct_UClass_AActor_NoRegister, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_EventInstigator = { UE4CodeGen_Private::EPropertyClass::Object, "EventInstigator", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventBlockDamage_Parms, EventInstigator), Z_Construct_UClass_AController_NoRegister, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_DamageEvent_MetaData[] = {
		{ "NativeConst", "" },
	};
#endif
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_DamageEvent = { UE4CodeGen_Private::EPropertyClass::Struct, "DamageEvent", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000008000182, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventBlockDamage_Parms, DamageEvent), Z_Construct_UScriptStruct_FDamageEvent, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_DamageEvent_MetaData, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_DamageEvent_MetaData)) };
	const UE4CodeGen_Private::FFloatPropertyParams Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_Damage = { UE4CodeGen_Private::EPropertyClass::Float, "Damage", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventBlockDamage_Parms, Damage), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_DamageCauser,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_EventInstigator,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_DamageEvent,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::NewProp_Damage,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Weapons like swords have the ability to block damage. The parameters are from the actor's take damage event.\n@param       Damage  Amount of damage taken.\n@param       DamageEvent     Data package that fully describes the damage received\n@param       EventInstigator         The Controller responsible for the damage\n@param       DamageCauser    The Actor that directly caused the damage (e.g. the projectile that exploded, or the enemy's sword)\n@return The remaining amount of damage after it's potential block." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "BlockDamage", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x08420C00, sizeof(AdvKitWeapon_eventBlockDamage_Parms), Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockDamage()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_BlockDamage_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics
	{
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_BlockedDamage;
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_By;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FFloatPropertyParams Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::NewProp_BlockedDamage = { UE4CodeGen_Private::EPropertyClass::Float, "BlockedDamage", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventBlockedBy_Parms, BlockedDamage), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::NewProp_By = { UE4CodeGen_Private::EPropertyClass::Object, "By", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventBlockedBy_Parms, By), Z_Construct_UClass_AActor_NoRegister, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::NewProp_BlockedDamage,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::NewProp_By,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback if an attack of this weapon was blocked by something\n@param       By      The actor that blocked the attack\n@param       BlockedDamage   How much damage was blocked" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "BlockedBy", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, sizeof(AdvKitWeapon_eventBlockedBy_Parms), Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockedBy()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_BlockedBy_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics
	{
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventCanFire_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventCanFire_Parms), &Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if the weapon can fire.\n@return True if it can, false if not" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "CanFire", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, sizeof(AdvKitWeapon_eventCanFire_Parms), Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanFire()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_CanFire_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics
	{
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventCanReload_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventCanReload_Parms), &Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if weapon can be reloaded.\n@return True if it can be reloaded." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "CanReload", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, sizeof(AdvKitWeapon_eventCanReload_Parms), Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanReload()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_CanReload_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Called when a shot is fired to use up ammunition." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "ConsumeAmmunition", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Called when firing to actually shoot. Depending on the fire type of the active mode it\ndelegates firing to FireInstant, FireProjectile or FireCustom." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "FireAmmunition", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_FireCustom_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_FireCustom_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Custom fire hook, for other implementations." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_FireCustom_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "FireCustom", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_FireCustom_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_FireCustom_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireCustom()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_FireCustom_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_FireInstant_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_FireInstant_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Fires instant trace, applies damage to hit target." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_FireInstant_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "FireInstant", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_FireInstant_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_FireInstant_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireInstant()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_FireInstant_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics
	{
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Object, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventFireProjectile_Parms, ReturnValue), Z_Construct_UClass_AAdvKitProjectile_NoRegister, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Fires a projectile configured by the current firing mode.\n@return The fired projectile, if successful" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "FireProjectile", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, sizeof(AdvKitWeapon_eventFireProjectile_Parms), Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireProjectile()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_FireProjectile_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics
	{
		struct AdvKitWeapon_eventGetAdjustedAim_Parms
		{
			FVector StartFireLocation;
			uint8 FireModeIndex;
			FRotator ReturnValue;
		};
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_StartFireLocation;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Struct, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetAdjustedAim_Parms, ReturnValue), Z_Construct_UScriptStruct_FRotator, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetAdjustedAim_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::NewProp_StartFireLocation = { UE4CodeGen_Private::EPropertyClass::Struct, "StartFireLocation", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetAdjustedAim_Parms, StartFireLocation), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::NewProp_FireModeIndex,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::NewProp_StartFireLocation,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "CPP_Default_FireModeIndex", "0" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Gets the direction in which to fire. Adds spread to it.\n@param       StartFireLocation       World space location to fire (bullet) from.\n@param       FireModeIndex   Fire mode might change the direction.\n@return Rotation with X axis facing in direction of fire." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "GetAdjustedAim", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04820400, sizeof(AdvKitWeapon_eventGetAdjustedAim_Parms), Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics
	{
		struct AdvKitWeapon_eventGetFireModeBP_Parms
		{
			uint8 FireModeIndex;
			UAdvKitFireModeConfiguration* ReturnValue;
		};
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Object, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetFireModeBP_Parms, ReturnValue), Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetFireModeBP_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::NewProp_FireModeIndex,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::Function_MetaDataParams[] = {
		{ "BlueprintProtected", "" },
		{ "Category", "Weapon" },
		{ "DisplayName", "Get Fire Mode Default Object" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Query a specific fire mode.\n@param       FireModeIndex   The mode to get\n@return Pointer to the fire mode if it exists, nullptr otherwise" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "GetFireModeBP", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04080401, sizeof(AdvKitWeapon_eventGetFireModeBP_Parms), Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics
	{
		struct AdvKitWeapon_eventGetFireModeClass_Parms
		{
			uint8 FireModeIndex;
			TSubclassOf<UAdvKitFireModeConfiguration>  ReturnValue;
		};
		static const UE4CodeGen_Private::FClassPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FClassPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Class, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0014000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetFireModeClass_Parms, ReturnValue), Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister, Z_Construct_UClass_UClass, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetFireModeClass_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::NewProp_FireModeIndex,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon" },
		{ "DisplayName", "Get Fire Mode" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Query a specific fire mode.\n@param       FireModeIndex   The mode to get\n@return Pointer to the class of the fire mode if it exists, nullptr otherwise" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "GetFireModeClass", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04080400, sizeof(AdvKitWeapon_eventGetFireModeClass_Parms), Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics
	{
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Struct, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetMuzzleLocation_Parms, ReturnValue), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetMuzzleLocation_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::NewProp_FireModeIndex,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "CPP_Default_FireModeIndex", "0" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Get the muzzle point of the weapon to spawn a projectile\n@param       FireModeIndex   If the weapon has more than one muzzle it can return different ones\n@return World space location of the muzzle" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "GetMuzzleLocation", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C820C00, sizeof(AdvKitWeapon_eventGetMuzzleLocation_Parms), Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics
	{
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Struct, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetTraceStart_Parms, ReturnValue), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetTraceStart_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::NewProp_FireModeIndex,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "CPP_Default_FireModeIndex", "0" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Get the starting location for a trace for projectile/instant fire mode. The default implementation\ntraces from the character's viewpoint to determine the target and then fires form the muzzle location\nto the hit.\n@param       FireModeIndex   Depending on fire mode the weapon can have different start locations.\n@return World space location of where to begin the trace" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "GetTraceStart", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C820C00, sizeof(AdvKitWeapon_eventGetTraceStart_Parms), Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics
	{
		struct AdvKitWeapon_eventGetWeaponCrosshairTexture_Parms
		{
			TSubclassOf<AAdvKitWeapon>  WeaponClass;
			UTexture2D* ReturnValue;
		};
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FClassPropertyParams NewProp_WeaponClass;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Object, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetWeaponCrosshairTexture_Parms, ReturnValue), Z_Construct_UClass_UTexture2D_NoRegister, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FClassPropertyParams Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::NewProp_WeaponClass = { UE4CodeGen_Private::EPropertyClass::Class, "WeaponClass", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0014000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventGetWeaponCrosshairTexture_Parms, WeaponClass), Z_Construct_UClass_AAdvKitWeapon_NoRegister, Z_Construct_UClass_UClass, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::NewProp_WeaponClass,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Get the crosshair texture of a weapon class without the need to instantiate it.\n\n@param       WeaponClass             Class of the weapon item to get the crosshair from.\n@return                                      Crosshair texture of the weapon." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "GetWeaponCrosshairTexture", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x14022401, sizeof(AdvKitWeapon_eventGetWeaponCrosshairTexture_Parms), Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Called if player wants to but the weapon cannot fire, e.g. to check if it needs to be reloaded." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "HandleFiringPrerequisites", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics
	{
		struct AdvKitWeapon_eventHasAmmunition_Parms
		{
			int32 Amount;
			bool ReturnValue;
		};
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_Amount;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventHasAmmunition_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventHasAmmunition_Parms), &Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::NewProp_Amount = { UE4CodeGen_Private::EPropertyClass::Int, "Amount", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventHasAmmunition_Parms, Amount), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::NewProp_Amount,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Ammunition" },
		{ "CPP_Default_Amount", "1" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if the weapon has a given amount of ammunition (disregarding if in magazine or not)\n@param       Amount  How much ammunition to ask for\n@return True if the weapon has at least the specified amount, false otherwise" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "HasAmmunition", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, sizeof(AdvKitWeapon_eventHasAmmunition_Parms), Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics
	{
		struct AdvKitWeapon_eventHasAmmunitionInMagazine_Parms
		{
			int32 Amount;
			bool ReturnValue;
		};
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_Amount;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventHasAmmunitionInMagazine_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventHasAmmunitionInMagazine_Parms), &Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::NewProp_Amount = { UE4CodeGen_Private::EPropertyClass::Int, "Amount", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventHasAmmunitionInMagazine_Parms, Amount), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::NewProp_Amount,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Ammunition" },
		{ "CPP_Default_Amount", "1" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if the weapon has a given amount of ammunition in the current magazine\n@param       Amount  How much ammunition to ask for\n@return True if the weapon has at least the specified amount, false otherwise" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "HasAmmunitionInMagazine", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, sizeof(AdvKitWeapon_eventHasAmmunitionInMagazine_Parms), Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics
	{
		struct AdvKitWeapon_eventHasFireMode_Parms
		{
			uint8 FireModeIndex;
			bool ReturnValue;
		};
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventHasFireMode_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventHasFireMode_Parms), &Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventHasFireMode_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::NewProp_ReturnValue,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::NewProp_FireModeIndex,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if the weapon has a specified fire mode.\n@param       FireModeIndex   The mode to check for\n@return True if mode exists, false otherwise" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "HasFireMode", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04080400, sizeof(AdvKitWeapon_eventHasFireMode_Parms), Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasFireMode()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_HasFireMode_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics
	{
		struct AdvKitWeapon_eventIsFiring_Parms
		{
			bool ReturnValue;
		};
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventIsFiring_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventIsFiring_Parms), &Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|State" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if the weapon is currently firing\n@return True if firing" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "IsFiring", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, sizeof(AdvKitWeapon_eventIsFiring_Parms), Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsFiring()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_IsFiring_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics
	{
		struct AdvKitWeapon_eventIsIdle_Parms
		{
			bool ReturnValue;
		};
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventIsIdle_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventIsIdle_Parms), &Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|State" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if the weapon is currently doing nothing\n@return True if doing nothing" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "IsIdle", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, sizeof(AdvKitWeapon_eventIsIdle_Parms), Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsIdle()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_IsIdle_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics
	{
		struct AdvKitWeapon_eventIsMagazineEmpty_Parms
		{
			bool ReturnValue;
		};
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventIsMagazineEmpty_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventIsMagazineEmpty_Parms), &Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Query if the magazine is empty\n@return True if empty" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "IsMagazineEmpty", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, sizeof(AdvKitWeapon_eventIsMagazineEmpty_Parms), Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics
	{
		struct AdvKitWeapon_eventIsReloading_Parms
		{
			bool ReturnValue;
		};
		static void NewProp_ReturnValue_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	void Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::NewProp_ReturnValue_SetBit(void* Obj)
	{
		((AdvKitWeapon_eventIsReloading_Parms*)Obj)->ReturnValue = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Bool, "ReturnValue", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000580, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AdvKitWeapon_eventIsReloading_Parms), &Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::NewProp_ReturnValue,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|State" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Check if the weapon is currently reloading\n@return True if reloading" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "IsReloading", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, sizeof(AdvKitWeapon_eventIsReloading_Parms), Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsReloading()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_IsReloading_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when the weapon starts firing." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnFireBegin", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when firing stops." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnFireEnd", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnFireShot_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnFireShot_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when FireAmmunition was called." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnFireShot_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnFireShot", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnFireShot_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnFireShot_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireShot()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnFireShot_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when the weapon wants to fire but there is no ammo left in the current magazine." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnMagazineEmpty", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when the weapon starts to reload." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnReloadBegin", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnReloaded_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnReloaded_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when the weapon has finished reloading." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnReloaded_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnReloaded", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnReloaded_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnReloaded_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloaded()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnReloaded_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when reloading was aborted." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnReloadEnd", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics
	{
		struct AdvKitWeapon_eventOnRep_BurstCounter_Parms
		{
			int32 OldBurstCounter;
		};
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_OldBurstCounter;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::NewProp_OldBurstCounter = { UE4CodeGen_Private::EPropertyClass::Int, "OldBurstCounter", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventOnRep_BurstCounter_Parms, OldBurstCounter), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::NewProp_OldBurstCounter,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::Function_MetaDataParams[] = {
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback method when the server burst counter changes\n@param OldBurstCounter        Counter before the change" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnRep_BurstCounter", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x00080400, sizeof(AdvKitWeapon_eventOnRep_BurstCounter_Parms), Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics
	{
		struct AdvKitWeapon_eventOnRep_WeaponState_Parms
		{
			FAdvKitWeaponState OldState;
		};
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_OldState;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::NewProp_OldState = { UE4CodeGen_Private::EPropertyClass::Struct, "OldState", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventOnRep_WeaponState_Parms, OldState), Z_Construct_UScriptStruct_FAdvKitWeaponState, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::NewProp_OldState,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::Function_MetaDataParams[] = {
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback method when the server state changes\n@param OldState      State before the change" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnRep_WeaponState", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x00080400, sizeof(AdvKitWeapon_eventOnRep_WeaponState_Parms), Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback event when the weapon wants to fire but has no mor ammunition." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "OnWeaponEmpty", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_RefireTimer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_RefireTimer_Statics::Function_MetaDataParams[] = {
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback method for refire timer" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_RefireTimer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "RefireTimer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x00020400, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_RefireTimer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_RefireTimer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_RefireTimer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_RefireTimer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Called when reloading succeeded. Moves ammunition from store to magazine." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "ReloadAmmunition", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer_Statics::Function_MetaDataParams[] = {
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Callback method for the reload timer." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "ReloadedTimer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x00080400, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics
	{
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventStartFire_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::NewProp_FireModeIndex,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "CPP_Default_FireModeIndex", "0" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Tell the weapon to start firing (even though the weapon may not be able to)\n@param       FireModeIndex   Which mode to start firing in" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartFire", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, sizeof(AdvKitWeapon_eventStartFire_Parms), Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFire()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartFire_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Internal method to actually start firing the pending or current fire mode." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartFireInternal", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics
	{
		static const UE4CodeGen_Private::FBytePropertyParams NewProp_FireModeIndex;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FBytePropertyParams Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::NewProp_FireModeIndex = { UE4CodeGen_Private::EPropertyClass::Byte, "FireModeIndex", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventStartFireServer_Parms, FireModeIndex), nullptr, METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::NewProp_FireModeIndex,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Server" },
		{ "CPP_Default_FireModeIndex", "0" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Server callback to tell the weapon to start firing (even though the weapon may not be able to)\n@param       FireModeIndex   Which mode to start firing in" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartFireServer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x84280CC0, sizeof(AdvKitWeapon_eventStartFireServer_Parms), Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireServer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartFireServer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics
	{
		struct AdvKitWeapon_eventStartRefireTimer_Parms
		{
			float Duration;
		};
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Duration;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
	const UE4CodeGen_Private::FFloatPropertyParams Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::NewProp_Duration = { UE4CodeGen_Private::EPropertyClass::Float, "Duration", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0010000000000080, 1, nullptr, STRUCT_OFFSET(AdvKitWeapon_eventStartRefireTimer_Parms, Duration), METADATA_PARAMS(nullptr, 0) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::NewProp_Duration,
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Starts the timer to do refires\n@param       Duration        How long to wait between fire calls" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartRefireTimer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, sizeof(AdvKitWeapon_eventStartRefireTimer_Parms), Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::PropPointers), 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartReload_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartReload_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Initiates a reload" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartReload_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartReload", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartReload_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartReload_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReload()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartReload_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Internal method to start reloading timer and animations." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartReloadInternal", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Server" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Server callback to initiate a reload" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartReloadServer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x84280CC0, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Start the timer for the reloading process. When the timer fires the reload is complete." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StartReloadTimer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopFire_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopFire_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Stop firing, the weapon may however still continue (e.g. because it needs to calm down first)" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopFire_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopFire", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopFire_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopFire_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFire()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopFire_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Internal method to actually stop firing the active mode." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopFireInternal", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopFireServer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopFireServer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Server" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Server callback to stop firing, the weapon may however still continue (e.g. because it needs to calm down first)" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopFireServer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopFireServer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x84280CC0, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopFireServer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopFireServer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireServer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopFireServer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Fire" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Stops refiring" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopRefireTimer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x04020400, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopReload_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopReload_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Stops a reload in progress without reloading ammo" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopReload_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopReload", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C020C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopReload_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopReload_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReload()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopReload_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Internal method to abort reload." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopReloadInternal", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon|Server" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Server callback to stop a reload in progress without reloading ammo" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopReloadServer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x84280CC0, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer_Statics::Function_MetaDataParams[] = {
		{ "Category", "Weapon Events|Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Stops the reload timer (aborting it)." },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AAdvKitWeapon, "StopReloadTimer", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x0C080C00, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer_Statics::Function_MetaDataParams, ARRAY_COUNT(Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitWeapon_NoRegister()
	{
		return AAdvKitWeapon::StaticClass();
	}
	struct Z_Construct_UClass_AAdvKitWeapon_Statics
	{
		static UObject* (*const DependentSingletons[])();
		static const FClassFunctionLinkInfo FuncInfo[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];
#endif
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Crosshair_MetaData[];
#endif
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_Crosshair;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ReloadTime_MetaData[];
#endif
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_ReloadTime;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AmmoByReloading_MetaData[];
#endif
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_AmmoByReloading;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_CharacterReloadMontage_MetaData[];
#endif
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_CharacterReloadMontage;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_FireModes_OLD_MetaData[];
#endif
		static const UE4CodeGen_Private::FArrayPropertyParams NewProp_FireModes_OLD;
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_FireModes_OLD_Inner;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DefaultFireModes_MetaData[];
#endif
		static const UE4CodeGen_Private::FArrayPropertyParams NewProp_DefaultFireModes;
		static const UE4CodeGen_Private::FClassPropertyParams NewProp_DefaultFireModes_Inner;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bHasInfiniteAmmunition_MetaData[];
#endif
		static void NewProp_bHasInfiniteAmmunition_SetBit(void* Obj);
		static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bHasInfiniteAmmunition;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_MaxAmmunition_MetaData[];
#endif
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_MaxAmmunition;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Ammunition_MetaData[];
#endif
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_Ammunition;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AmmunitionInMagazine_MetaData[];
#endif
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_AmmunitionInMagazine;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AmmunitionPerMagazine_MetaData[];
#endif
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_AmmunitionPerMagazine;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DefaultRootComponent_MetaData[];
#endif
		static const UE4CodeGen_Private::FObjectPropertyParams NewProp_DefaultRootComponent;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BurstCounter_MetaData[];
#endif
		static const UE4CodeGen_Private::FIntPropertyParams NewProp_BurstCounter;
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_WeaponState_MetaData[];
#endif
		static const UE4CodeGen_Private::FStructPropertyParams NewProp_WeaponState;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
		static const FCppClassTypeInfoStatic StaticCppClassTypeInfo;
		static const UE4CodeGen_Private::FClassParams ClassParams;
	};
	UObject* (*const Z_Construct_UClass_AAdvKitWeapon_Statics::DependentSingletons[])() = {
		(UObject* (*)())Z_Construct_UClass_AAdvKitInventoryItem,
		(UObject* (*)())Z_Construct_UPackage__Script_AdvKitRuntime,
	};
	const FClassFunctionLinkInfo Z_Construct_UClass_AAdvKitWeapon_Statics::FuncInfo[] = {
		{ &Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition, "AddAmmunition" }, // 684977774
		{ &Z_Construct_UFunction_AAdvKitWeapon_AddSpread, "AddSpread" }, // 2359946995
		{ &Z_Construct_UFunction_AAdvKitWeapon_BlockDamage, "BlockDamage" }, // 1310611916
		{ &Z_Construct_UFunction_AAdvKitWeapon_BlockedBy, "BlockedBy" }, // 2797899189
		{ &Z_Construct_UFunction_AAdvKitWeapon_CanFire, "CanFire" }, // 1803929937
		{ &Z_Construct_UFunction_AAdvKitWeapon_CanReload, "CanReload" }, // 1100030892
		{ &Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition, "ConsumeAmmunition" }, // 952235125
		{ &Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition, "FireAmmunition" }, // 2685412614
		{ &Z_Construct_UFunction_AAdvKitWeapon_FireCustom, "FireCustom" }, // 3149317071
		{ &Z_Construct_UFunction_AAdvKitWeapon_FireInstant, "FireInstant" }, // 2178644436
		{ &Z_Construct_UFunction_AAdvKitWeapon_FireProjectile, "FireProjectile" }, // 4229518382
		{ &Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim, "GetAdjustedAim" }, // 1640547801
		{ &Z_Construct_UFunction_AAdvKitWeapon_GetFireModeBP, "GetFireModeBP" }, // 2475449070
		{ &Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass, "GetFireModeClass" }, // 4271074246
		{ &Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation, "GetMuzzleLocation" }, // 3084550310
		{ &Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart, "GetTraceStart" }, // 1180770082
		{ &Z_Construct_UFunction_AAdvKitWeapon_GetWeaponCrosshairTexture, "GetWeaponCrosshairTexture" }, // 3009188122
		{ &Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites, "HandleFiringPrerequisites" }, // 3495628589
		{ &Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition, "HasAmmunition" }, // 2812526815
		{ &Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine, "HasAmmunitionInMagazine" }, // 759349041
		{ &Z_Construct_UFunction_AAdvKitWeapon_HasFireMode, "HasFireMode" }, // 1736415428
		{ &Z_Construct_UFunction_AAdvKitWeapon_IsFiring, "IsFiring" }, // 2964276888
		{ &Z_Construct_UFunction_AAdvKitWeapon_IsIdle, "IsIdle" }, // 135019633
		{ &Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty, "IsMagazineEmpty" }, // 1073766339
		{ &Z_Construct_UFunction_AAdvKitWeapon_IsReloading, "IsReloading" }, // 704237130
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin, "OnFireBegin" }, // 3418499370
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd, "OnFireEnd" }, // 48518457
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnFireShot, "OnFireShot" }, // 1373035367
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty, "OnMagazineEmpty" }, // 3029576009
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin, "OnReloadBegin" }, // 2764918781
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnReloaded, "OnReloaded" }, // 1417846229
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd, "OnReloadEnd" }, // 4007526948
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnRep_BurstCounter, "OnRep_BurstCounter" }, // 3294409012
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState, "OnRep_WeaponState" }, // 2995045797
		{ &Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty, "OnWeaponEmpty" }, // 874891766
		{ &Z_Construct_UFunction_AAdvKitWeapon_RefireTimer, "RefireTimer" }, // 4057443031
		{ &Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition, "ReloadAmmunition" }, // 1050315917
		{ &Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer, "ReloadedTimer" }, // 939593129
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartFire, "StartFire" }, // 387368343
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal, "StartFireInternal" }, // 178594535
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartFireServer, "StartFireServer" }, // 1524524479
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer, "StartRefireTimer" }, // 3426686455
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartReload, "StartReload" }, // 4210828254
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal, "StartReloadInternal" }, // 873007741
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer, "StartReloadServer" }, // 2772158370
		{ &Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer, "StartReloadTimer" }, // 3299189861
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopFire, "StopFire" }, // 1438198908
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal, "StopFireInternal" }, // 2028287281
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopFireServer, "StopFireServer" }, // 4163283767
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer, "StopRefireTimer" }, // 3159594317
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopReload, "StopReload" }, // 3619161289
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal, "StopReloadInternal" }, // 3108962775
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer, "StopReloadServer" }, // 2075476721
		{ &Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer, "StopReloadTimer" }, // 4284552905
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::Class_MetaDataParams[] = {
		{ "IncludePath", "Items/AdvKitWeapon.h" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ObjectInitializerConstructorDeclared", "" },
		{ "ToolTip", "@brief Base weapon class. Has some basic replicated handling on start-/stop firing and fire modes, as\nwell as base methods to implement custom behaviors.\n\nFor this explanation the weapon is described like a gun, even though the weapon functionality\nis not limited to guns. Calling StartFire implies that the trigger has been pulled. If the gun\nis currently firing on an alternate mode it will stop doing that and start the new mode by calling\nStartFireInternal. Here last checks are done, e.g. if there is enough ammunition and the weapon\nwill be reloaded if there isn't. If all prerequisites are met the weapon will actually fire by\ncalling FireAmmunition and then start a refire timer if configured.\n\nStopFire works in a similar matter. You should see Start-/StopFire as intents of the player, while\nthe corresponding internal methods are the actual clockwork that govern what the weapon does." },
	};
#endif
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Crosshair_MetaData[] = {
		{ "Category", "Effects" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Optional texture to display on the HUD" },
	};
#endif
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Crosshair = { UE4CodeGen_Private::EPropertyClass::Object, "Crosshair", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010015, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, Crosshair), Z_Construct_UClass_UTexture2D_NoRegister, METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Crosshair_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Crosshair_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_ReloadTime_MetaData[] = {
		{ "Category", "Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "How long a reload takes." },
	};
#endif
	const UE4CodeGen_Private::FFloatPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_ReloadTime = { UE4CodeGen_Private::EPropertyClass::Float, "ReloadTime", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010001, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, ReloadTime), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_ReloadTime_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_ReloadTime_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmoByReloading_MetaData[] = {
		{ "Category", "Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "How much ammunition is added with each reload." },
	};
#endif
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmoByReloading = { UE4CodeGen_Private::EPropertyClass::Int, "AmmoByReloading", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010001, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, AmmoByReloading), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmoByReloading_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmoByReloading_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_CharacterReloadMontage_MetaData[] = {
		{ "Category", "Reload" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Optional anim montage to play character animation when reloading." },
	};
#endif
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_CharacterReloadMontage = { UE4CodeGen_Private::EPropertyClass::Object, "CharacterReloadMontage", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010001, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, CharacterReloadMontage), Z_Construct_UClass_UAnimMontage_NoRegister, METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_CharacterReloadMontage_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_CharacterReloadMontage_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_FireModes_OLD_MetaData[] = {
		{ "Category", "FireModes" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "List of fire modes the weapon has" },
	};
#endif
	const UE4CodeGen_Private::FArrayPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_FireModes_OLD = { UE4CodeGen_Private::EPropertyClass::Array, "FireModes_OLD", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000000034, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, FireModes_OLD), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_FireModes_OLD_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_FireModes_OLD_MetaData)) };
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_FireModes_OLD_Inner = { UE4CodeGen_Private::EPropertyClass::Object, "FireModes_OLD", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0000000000000000, 1, nullptr, 0, Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultFireModes_MetaData[] = {
		{ "Category", "FireModes" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Which fire modes the weapon should have, will be instantiated on startup" },
	};
#endif
	const UE4CodeGen_Private::FArrayPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultFireModes = { UE4CodeGen_Private::EPropertyClass::Array, "DefaultFireModes", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0024080000010021, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, DefaultFireModes), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultFireModes_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultFireModes_MetaData)) };
	const UE4CodeGen_Private::FClassPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultFireModes_Inner = { UE4CodeGen_Private::EPropertyClass::Class, "DefaultFireModes", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0004000000000000, 1, nullptr, 0, Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister, Z_Construct_UClass_UClass, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_bHasInfiniteAmmunition_MetaData[] = {
		{ "Category", "Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "This weapon has infinite Ammunition" },
	};
#endif
	void Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_bHasInfiniteAmmunition_SetBit(void* Obj)
	{
		((AAdvKitWeapon*)Obj)->bHasInfiniteAmmunition = 1;
	}
	const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_bHasInfiniteAmmunition = { UE4CodeGen_Private::EPropertyClass::Bool, "bHasInfiniteAmmunition", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010015, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(AAdvKitWeapon), &Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_bHasInfiniteAmmunition_SetBit, METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_bHasInfiniteAmmunition_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_bHasInfiniteAmmunition_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_MaxAmmunition_MetaData[] = {
		{ "Category", "Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "How much ammunition the weapon can hold" },
	};
#endif
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_MaxAmmunition = { UE4CodeGen_Private::EPropertyClass::Int, "MaxAmmunition", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010015, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, MaxAmmunition), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_MaxAmmunition_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_MaxAmmunition_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Ammunition_MetaData[] = {
		{ "Category", "Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "How much ammunition the weapon has" },
	};
#endif
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Ammunition = { UE4CodeGen_Private::EPropertyClass::Int, "Ammunition", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010035, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, Ammunition), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Ammunition_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Ammunition_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionInMagazine_MetaData[] = {
		{ "Category", "Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "How much ammunition is left in the current magazine" },
	};
#endif
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionInMagazine = { UE4CodeGen_Private::EPropertyClass::Int, "AmmunitionInMagazine", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010015, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, AmmunitionInMagazine), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionInMagazine_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionInMagazine_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionPerMagazine_MetaData[] = {
		{ "Category", "Ammunition" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "How much ammunition is held in a single magazine" },
	};
#endif
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionPerMagazine = { UE4CodeGen_Private::EPropertyClass::Int, "AmmunitionPerMagazine", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080000010015, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, AmmunitionPerMagazine), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionPerMagazine_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionPerMagazine_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultRootComponent_MetaData[] = {
		{ "Category", "Weapon" },
		{ "EditInline", "true" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
	};
#endif
	const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultRootComponent = { UE4CodeGen_Private::EPropertyClass::Object, "DefaultRootComponent", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x00200800000a001d, 1, nullptr, STRUCT_OFFSET(AAdvKitWeapon, DefaultRootComponent), Z_Construct_UClass_USceneComponent_NoRegister, METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultRootComponent_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultRootComponent_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_BurstCounter_MetaData[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Shot counter to replicate weapon effects" },
	};
#endif
	const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_BurstCounter = { UE4CodeGen_Private::EPropertyClass::Int, "BurstCounter", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080100000034, 1, "OnRep_BurstCounter", STRUCT_OFFSET(AAdvKitWeapon, BurstCounter), METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_BurstCounter_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_BurstCounter_MetaData)) };
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_WeaponState_MetaData[] = {
		{ "Category", "Weapon" },
		{ "ModuleRelativePath", "Public/Items/AdvKitWeapon.h" },
		{ "ToolTip", "Struct holding all state variables of the weapon" },
	};
#endif
	const UE4CodeGen_Private::FStructPropertyParams Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_WeaponState = { UE4CodeGen_Private::EPropertyClass::Struct, "WeaponState", RF_Public|RF_Transient|RF_MarkAsNative, (EPropertyFlags)0x0020080100000034, 1, "OnRep_WeaponState", STRUCT_OFFSET(AAdvKitWeapon, WeaponState), Z_Construct_UScriptStruct_FAdvKitWeaponState, METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_WeaponState_MetaData, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_WeaponState_MetaData)) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UClass_AAdvKitWeapon_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Crosshair,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_ReloadTime,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmoByReloading,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_CharacterReloadMontage,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_FireModes_OLD,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_FireModes_OLD_Inner,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultFireModes,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultFireModes_Inner,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_bHasInfiniteAmmunition,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_MaxAmmunition,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_Ammunition,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionInMagazine,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_AmmunitionPerMagazine,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_DefaultRootComponent,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_BurstCounter,
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AAdvKitWeapon_Statics::NewProp_WeaponState,
	};
	const FCppClassTypeInfoStatic Z_Construct_UClass_AAdvKitWeapon_Statics::StaticCppClassTypeInfo = {
		TCppClassTypeTraits<AAdvKitWeapon>::IsAbstract,
	};
	const UE4CodeGen_Private::FClassParams Z_Construct_UClass_AAdvKitWeapon_Statics::ClassParams = {
		&AAdvKitWeapon::StaticClass,
		DependentSingletons, ARRAY_COUNT(DependentSingletons),
		0x009000A1u,
		FuncInfo, ARRAY_COUNT(FuncInfo),
		Z_Construct_UClass_AAdvKitWeapon_Statics::PropPointers, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::PropPointers),
		nullptr,
		&StaticCppClassTypeInfo,
		nullptr, 0,
		METADATA_PARAMS(Z_Construct_UClass_AAdvKitWeapon_Statics::Class_MetaDataParams, ARRAY_COUNT(Z_Construct_UClass_AAdvKitWeapon_Statics::Class_MetaDataParams))
	};
	UClass* Z_Construct_UClass_AAdvKitWeapon()
	{
		static UClass* OuterClass = nullptr;
		if (!OuterClass)
		{
			UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_AAdvKitWeapon_Statics::ClassParams);
		}
		return OuterClass;
	}
	IMPLEMENT_CLASS(AAdvKitWeapon, 3848540989);
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitWeapon(Z_Construct_UClass_AAdvKitWeapon, &AAdvKitWeapon::StaticClass, TEXT("/Script/AdvKitRuntime"), TEXT("AAdvKitWeapon"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitWeapon);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
#ifdef _MSC_VER
#pragma warning (pop)
#endif
